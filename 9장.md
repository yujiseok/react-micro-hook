# 사용 사례 시나리오: Valtio

Valtio는 변경 가능한 갯인 모델 기반
Valtio는 프록시를 사용해 변경 불가능한 스냅샷을 가져옴
프록시 사용으로 리렌더링 자동 최적화 됨

-> 상태 사용 추적이라는 기법을 기반함
사용된 부분이 변경될 경우에만 컴포넌트 리렌더링 되게 할 수 있다.

## 또 다른 모듈 상태 라이브러리인 Valtio 살펴보기

발티오는 모듈 상태를 사용 -> zustand와 동일
주스탠드와 같이 스토어 생성할 수 있음

스토어에서 상태르 변경할 경우 `Object.assign` 메서드를 사용함 -> 객체를 불변하게 갱신
만약 직접 객체의 값을 변경할 경우 (불변하지 않음) -> 리액트가 알아차릴 수 없음

프록시를 사용하면 직접 변경이 가능하다.

```ts
const proxy = new Proxy(
  {
    count: 0,
    text: "hello",
  },
  {
    set: (target, prop, value) => {
      console.log("start setting", prop);
      target[prop] = value;
      console.log("end setting", prop);
    },
  }
);
```

프록시 객체를 생성함 프록시는 타겟 객체와 핸들러를 담는 객체를 인수로 받는다.
set의 경우 객체의 값이 갱신될 경우 실행됨

개념적으로 프록시는 모든 변경을 감지할 수 있다.

## 프록시를 활용한 변경 감지 및 불변 상태 생성하기

발티오는 프록시를 활용해 불변 객체를 만든다.
이 불변 객체가 스냅샷이다.

- 프록시로 만든 객체 === 변경을 감지하는 객체
- 스냅샷으로 만든 객체 === 불변 객체

각 변경에 따른 동등성을 확인하고 객체에서 어떤 부분이 다른지 파악함
중첩된 객체 역시 스냅샷으로 최적화 된다. -> 변경되지 않은 객체는 참조가 같음 -> 메모리 공유 -> 메모리 절약

추적 정보를 가지고 리렌더링을 최적화한다.

중첩 객체, 배열 등 복잡한 구조도 당연히 지원함

## 작은 애플리케이션 만들어 보기

투두앱
리렌더링을 줄이고 싶다면, 아이디를 넘겨서 아이디로 각 리스트아이템에서 투두를 가져오자

## 이 접근 방식의 장단점

발티오는 직접 상태를 업데이트할 수 있는 모델을 사용함.
리액트는 불변 상태를 중심으로 업데이트. 두 모델을 분리해서 사용하자.

불변 갱신은 때로 유쾌하지 않은 DX를 준다.

또 발티오는 구조분해로 각 값을 가져올 수 있지만, 선택자 기반 라이브러리는 훅으로 가져와야함
조건이 많을수록 더 많은 훅이 필요하다.

발티오는 리렌더링 최적화가 그 내부에 되어있어, 예측 가능성이 떨어진다.
