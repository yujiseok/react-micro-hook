# 1장 리액트 훅을 이용한 마이크로 상태 관리

## 전통적인 상태 관리란?

- 상태 관리를 위한 프레임워크를 사용해 목적에 맞게 해결하는 중앙 집중적인 방식을 사용함

## 리액트 훅의 등장

- 상태관리를 위한 기본적인 훅을 사용할 수 있게 됨 → `useState` , `useReducer`
- 훅은 재사용과 경량화에 용이하다. → 그 결과 마이크로 상태 관리가 가능하다.

> 💡 마이크로 상태 관리?
>
> - **가벼움**: 범용적인 상태 관리 방법은 가볍게 구현되어야 한다.
> - **유연성**: 개발자의 요구사항에 따라 적절한 방법을 선택할 수 있어야 한다. →자유도? 🆓
> - **지역성 중시**: 컴포넌트 모델에 기반해 컴포넌트 간 격리와 재사용을 강조한다.

리액트는 지역 상태를 제어할 수 있는 다양한 기능을 이미 제공한다. 하지만, 전역 상태는 리액트에서 까다롭다.

→ 전역 상태 관리에 대한 기능을 완전히 커뮤니티에 위임함 → 너무 무책임한 거 아님?! 😵‍💫

> 💡 왜 전역 상태 관리가 어려울까?
> 리액트의 단방향 데이터 흐름이 전역 상태 관리를 어렵게 만든 것이 아닐까라고 생각함.
> 위에서 아래(부모에서 자식으로) 흐를 수 밖에 없는데, 계층 구조가 깊을 수록 데이터를 내려주는 것과 그 데이터를 추적하는 것이 어렵다.
>
> 단방향 데이터 흐름의 장점은?
>
> 예측 가능성: 데이터가 한 방향으로 흐르기 때문에 추적하기 쉽다 → 깊어지면?
> 복잡성 감소: 양방향 데이터 바인딩과 다르게 데이터 흐름의 복잡도가 낮다.
> 컴포넌트 재사용성 증가: 주어진 데이터 즉 props에 따라 동작하므로 재사용이 쉽다.
> 상태 관리의 일관성 증가

## 마이크로 상태 관리 이해하기

리액트에서 **상태**는 **UI**를 나타내는 모든 데이터를 말한다. 상태는 시간에 따라 변경되고, 리액트는 상태와 함께 렌더링할 컴포넌트를 처리한다.

기존 중앙 집중형 상태 관리 라이브러리로 관리할 수 있지만, 너무 비대해짐
리액트의 훅은 목적에 따른 해결책을 제공할 수 있게 됐다.

- 폼 상태는 전역 상태에 의존할 필요 없는 독자적인 상태
- 서버 캐시 상태는 일반적인 상태와 다른 리페칭과 같은 고유한 상태가 존재
- 네비게이션 상태의 주체가 브라우저 → 단일 상태로 적합하지 않음

위와 같은 문제를 해결하기 위해, 즉 특정한 문제를 해결하기 위한 다양한 훅 라이브러리가 존재한다. (**목적 지향 상태 관리 라이브러리 💫**)

> 예를 들면, 폼을 위한 리액트 훅 폼, 서버 캐시 상태를 위한 리액트 쿼리, 라우팅을 위한 리액트 라우터 돔

특정한 목적을 가지며 범용적으로 사용할 수 있는 상태 관리를 마이크로 상태 관리라고 한다.

- 즉 개발자에게 자유도가 높은 오픈 월드
- MSM의 필수 요소
  - 상태 읽기
  - 상태 갱신
  - 상태 기반 렌더링
- 추가 요소
  - 리렌더링 최적화
  - 다른 시스템과 상호 작용
  - 비동기 지원
  - 파생 상태
  - 간단한 문법 → 제일 중요..😵‍💫
- 모두 필요한 건 아니고 진리의 케바케
- 학습하기 쉬워야함

## 리액트 훅 사용하기

상태 관리를 위해 훅은 당연히 필수.

### useState

- 지역 상태를 만들어주는 아주 기초적인 상태 관리 훅
- 로직을 캡슐화 → 사용자 정의 훅을 만들게 해줌

### useReducer

- 리듀서를 통해 상태와 상태를 처리하는 로직을 분리할 수 있다.
- 좀 더 복잡한 상태 관리를 처리할 수 있음

### useEffect

- 리액트의 렌더링 과정 외부에서 로직을 실행할 수 있다.
- 리액트에 의존하지 않는 어떤 로직을 실행할 때

훅의 좋은 점은 상태 관리를 UI에서 분리할 수 있다는 것 → 관심사의 분리?!

- 커스텀 훅을 통해 명확한 명명을 할 수 있다. → 가독성 증가
- 컴포넌트에 의존 되지 않도록 로직을 분리할 수 있다. → 유지보수성 증가
  - 훅의 로직만 변경해 원하는 결과를 얻는다.

### 동시성과 서스펜스

동시성

[동시성](https://github.com/reactwg/react-18/discussions/46#discussioncomment-846786)(Concurrency)은 말 그대로 동시에 작업이 실행되는 것.

여러 작업을 동시에 실행하는 데 그냥 단순히 “여러” 작업이 중요한 것이 아니라, “긴급함”이 중요하다.
긴급하지 않은 작업을 잠시 중단하고 긴급한 작업 우선 처리 후 돌아온다.

서스펜스

서스펜스(Suspense)의 사전적 의미는 긴장감, 정지 또는 미결을 의미한다.

> 💃🏻 [네이버 드라마사전](https://terms.naver.com/entry.naver?docId=390177&cid=42612&categoryId=42612)에서 재밌는 뜻을 발견
> 서스펜스는 연극이나 영화에서 관객에게 불안과 긴장을 주어 흥미를 복돋워주는 기법이라고 한다.
> 한 번에 모든 것을 제공하면 관객의 관심은 사라지지만, 서스펜스를 통해 관객의 기대를 받을 수 있다.
> 즉, 정점에 도달하기 위해 심어두는 장치.
>
> 이걸 프론트엔드 개발적 시각에서 본다면, 서스펜스의 fallback을 통해 유저(관객)에게 어떤 UI가 등장할 것이라는 관심과 흥미를 줄 수 있는 개발자의 장치라고 할 수도 있겠다. 학수고대 UI..

좀 더 프로그래밍스러운 [간단한 예시](https://github.com/reactwg/react-18/discussions/46#discussioncomment-846771)는, 준비가 덜 된(`pending`) 어떤 컴포넌트가 나 아직 준비가 덜 됐어라고 아우성 치는 것을 그 컴포넌트와 **가장 가까운** 서스펜스에서 잡아 준비가 될 때(`reslove`)까지 fallback UI를 보여주는 것. 프로미스가 전부 이행되면, 리액트는 리렌더링을 시도한다.

## 전역 상태 탐구하기

지역적 상태를 관리하기 위해선 `useState` 를 사용할 수 있다.

반면 전역 상태는 컴포넌트 간 계층이 먼 경우 여러 컴포넌트에서 사용하는 상태다. 전역 상태는 **싱글턴**일 필요 없으며, 전역 상태를 공유 상태라고 하자.

> 📦 싱글턴?
> 싱글턴 패턴은 장난감 상자와 같다. 장난감 상자는 다음과 같이 동작한다.
>
> 1. 상자는 오직 하나: 아무리 많은 상자를 원해도 항상 동일한 상자를 받는다.
> 2. 모두 같은 상자를 공유: 나 너 혹은 우리 모두 똑같은 상자를 받는다.
> 3. 상자 안의 물건은 모두의 것: 내가 상자에 장난감을 넣었다면, 다른 사람도 장난감을 가지고 놀 수 있다.
>
> 모든 사람이 같은 정보를 통해 같은 내용을 알 수 있다. → 공유 경제 아잉교..

[싱글턴 패턴](https://www.patterns.dev/vanilla/singleton-pattern)은 한 번의 초기화를 통해 전역에서 접근할 수 있도록 한다.
전역 상태 관리와 유사하지만, 상태를 직접 변경할 수 있다(`mutable`)는 것이 차이일까? → 리덕스를 예를 들면, 상태 변경을 위해선 컴포넌트에서 디스패치로 전달된 액션을 순수함수인 `reducer` 함수로 변경해야한다.

전역 상태가 어려운 이유는 역시나 컴포넌트 모델과 연관

- 컴포넌트 모델에서는 아무래도 지역성이 중요함
- 컴포넌트는 사실 함수 → 함수는 재사용 가능한 기능의 단위
- 독립성이 중요
- 외부에 의존도가 높으면 제대로 동작하기 어려움
- 그러므로 전역 상태에 의존하는 것은 안좋음

### useState 사용하기

값으로 상태 갱신하기

- 새로운 값을 제공해 상태 갱신
- 만약 이전 상태와 변경된 상태가 같다면 → 베일아웃(bailout)을 통해 리렌더링이 발생하지 않는다.

> 💡 베일 아웃?
> 베일아웃은 구제금융, 보석금을 낸다. 파산 위기의 기업 국가를 외부에서 자금을 지원해 구원하는 것을 의미한다는데, 베일아웃 없이 계속 리렌더링이 일어나면 리액트 앱이 터져서 이렇게 명명했나?

- 객체를 값에 제공하면 베일아웃이고 뭐고 파산
  - 객체는 항상 새로운 객체를 생성해서 이전 객체와 달라서 동일하지 않음
- 함수형 업데이트

  - 기본적으로 `setState` 는 비동기적으로 동작해 몇 가지 문제가 발생한다.

    - 상태 업데이트 지연: 변경된 직후 상태를 읽을 경우 이전 값을 얻게 된다. → 리액트는 상태를 스냅샷을 가지고 있어서.
    - 예시
      ```jsx
      const handleClick = () => {
        setCount(count + 1);
        console.log(count); // 여전히 이전 값을 출력
      };
      ```
    - 연속 업데이트 문제
    - 예시

      ```jsx
      const [value, setValue] = useState(0);

      const onClick = () => {
        setValue(value + 1);
        setValue(value + 1);
        setValue(value + 1);
      };
      ```

  - 함수형 업데이트를 사용하면, 이전 상태를 계산할 수 있다.
    - 어떤 상태의 변경을 연속적으로 할 경우 → 이전 상태를 기반해 예측 가능한 업데이트 가능

- [지연 초기화](https://react.dev/reference/react/useState#parameters)(Lazy initialization)
  - 상태 초기화 시 함수를 전달하면, 리액트는 초기 상태를 최초 1회만 저장하고 그 이후는 무시한다.
    - ~~마운트와 렌더링을 헷갈리지 말자~~
  - 함수 실행을 전달하는 게 아니라, 함수 자체를 전달해야 함
  - 함수 조건
    - 순수함수
    - 인수 불필요
    - 반드시 어떤 타입을 반환해야 함
  - 연산이 오래 걸리는 경우 지연 초기화를 사용하면 좋겠다.
  - 항상 무거운 계산에서 무겁다라는 기준을 모르겠다.

### useReducer 사용하기

`useState` 와 다르게 `useReducer` 는 복잡한 상태 관리에 유용하다.

훅 외부로 상태 변경을 위한 리듀서 함수를 분리할 수 있다. 리듀서는 순수함수여서 동작 테스트가 용이하다.

- 베일아웃 시에는 새로운 객체가 아닌 상태 자체를 반환하는 것이 좋음
- 마찬가지로 지연 초기화 가능
- 디스패치 함수에 상호 작용 즉 액션을 전달해 상태 변경
